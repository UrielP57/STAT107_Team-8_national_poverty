##Question: Is there a statistically significant correlation between inflation rates and the Poverty headcount ratio across countries worldwide?

---
title: 'STAT 107 Project:PHC'
author: "Marianne, Donnie, Uriel"
date: '2025-10-14'
output:
  pdf_document: default
  html_document: default
---
##Introduction (work in progress)
#Purpose:
To created and train a model to not only establish a connection between the Poverty headcount ratio and Inflation. But potential create a means to see trends that will eventually help foresee potential spikes of inflation worldwide.

#Question
The question we are attempting to answer is whether or not there is a statistically significant correlation between inflation rates and the Poverty headcount ratio across countries worldwide?

#Benefit:
This analysis should be to benefit government institutions that not only track but try to influence how much inflation would inflict upon society as a whole. This would implicate federal policies that end up being passed or killed in the senate. Which in turn would affect local business all the way to international ones. 

#Plan:
We hope to answer our hypothesis since, if we are able to establish a connection between inflation to PHC. Then going forward it would be possible to train a model that could potential forecast the trends of inflation which would help government bodies worldwide create plans to counteract these shifts. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Data 
The data that is available is NEW_DDAY (Poverty Head Count at $3.00 a day (2021 PPP)), API_1 and API_2 are from the same data set (Inflation consumer prices (annual %) for the World, Grow (Population growth (annual%)). However API_2 is less about data and more of the information it can present since it contains notes left behind from the makers of the csv file. 
##Data sets:
```{r}
ND <- read.csv("New_DDAY.csv")
API <- read.csv("API_A.csv")
SN_API <- read.csv("API_B.csv")
Pop_Growth <- read.csv("Pop_Growth.csv")
```

##Cleaning the Data:
For each of the three data sets, it was needed to recreate a data frame since the original csv file showed each excel file to have their rows and columns in the wrong place. Since basic R function like summary() or mean() would grab information from the file's columns, it would output an answer. However the number results would be wrong since it would be grabbing all 270 countries info for 1960. So after swapping the column and rows into the new data frame, (idk where this is going)
#Code for New_DDAY

```{r}
#Item names: row_ND, not_imp, ind_row, RC, row_ND,vari_RC.
row_ND <- c() 
not_imp <- c() #useless vector
for (ind_row in rownames(ND)){
  for (i in ND[ind_row,]){
    RC <- as.character(i)
    if (is.na(RC)){
      RC <- 0
      row_ND <- c(row_ND, RC)
      
     } else {
       vari_RC <- suppressWarnings(as.numeric(RC))
                                      
                                      
        if (!is.na(vari_RC)){
          row_ND <- c(row_ND, RC)
          }  else if (RC != ""){
          not_imp <- c(not_imp, RC)
          }
    }
  }
}
```

# Get groups of 270 and each group has a length of 65. Then use split() to apply that row_ND
```{r}
a <- row_ND
ND_by_65 <- rep(1:270, each = 65)
fin_ND <- split(a, ND_by_65)

```


## Data Frame for ND with rows and columns switched: df_ND
```{r}
# must have this chunk running first if you want the other similar section to function!!
col_nm <- ND[,1][5:270]
df_ND <- data.frame(fin_ND[5:270])

colnames(df_ND) <- c(col_nm)
years <- c(1960:2024) 
rownames(df_ND) <- c(years)
```

##Supporting data sets: API and Pop_Growth

```{r}
#Item names: row_API, not_imp_2, ind_API, RC_2,vari_RC_2.
row_API <- c() 
not_imp_2 <- c() #useless vector
for (ind_API in rownames(API)){
  for (i in API[ind_API,]){
    RC_2 <- as.character(i)
    if (is.na(RC_2)){
      RC_2 <- 0
      row_API <- c(row_API, RC_2)
      
     } else {
       vari_RC_2 <- suppressWarnings(as.numeric(RC_2))
                                    
                                    
        if (!is.na(vari_RC_2)){
          row_API <- c(row_API, RC_2)
          } else if (RC_2 != ""){
          not_imp_2 <- c(not_imp_2, RC_2)
        }
    }
  }
}
```


```{r}
b <- row_API
API_by_65 <- rep(1:270, each = 65)
fin_API <- split(b, API_by_65)
```

##Data Frame for API with rows and columns switched: df_API
```{r}
col_nm_2 <- API[,1][5:270]
df_API <- data.frame(col_nm = fin_API[5:270])

colnames(df_API) <- c(col_nm_2)
rownames(df_API) <- c(years)

i = 1
while ( i < 267 ){
  #(i)
  #print((summary(as.double(df_API[,i]))))
  #have a pound sign so not to clogged the file
  i = i + 1
  
}
```



##Pop_Growth
```{r}
#Item names: row_PG, NI, ind_PG, RC_3,vari_RC_3.
row_PG <- c()
NI <- c() #useless vector
for (ind_PG in rownames(Pop_Growth)){
  for (i in Pop_Growth[ind_PG,]){
    RC_3 <- as.character(i)
    if (is.na(RC_3)){
      RC_3 <- 0
      row_PG <- c(row_PG, RC_3)
      
     } else {
       vari_RC_3 <- suppressWarnings(as.numeric(RC_3))
                                    
                                    
                                    
      if (!is.na(vari_RC_3)){
        row_PG <- c(row_PG, RC_3)
      } else if (RC_3 != ""){
        NI <- c(NI, RC_3)
        }
    }
  }
}
```

#Look at main data set grouping section for explanation
```{r}
c <- row_PG
PG_by_65 <- rep(1:270, each = 65)
fin_PG <- split(c, PG_by_65)
```

##Data Frame for Pop_Growth with rows and columns switched: df_PG
```{r}
col_nm_3 <- Pop_Growth[,1][5:270]
df_PG <- data.frame(col_nm = fin_PG[5:270])

colnames(df_PG) <- c(col_nm_3)
rownames(df_PG) <- c(years)



```
#Variables and number of observations:

1. How many observations: `nrow()` function.
2. How many variables: `ncol()` function.
3. Dimensions of data frame: `dim()` function.

```{r}
print("All three Data Sets have the same rows, columns and dimensions")
nrow(df_ND) # No. of observations.
ncol(df_ND) # No. of variables of interest.
dim(df_ND)  # both.
```

#Will the data be generated through a randomized simulation?
It is possible since it would depend on whether or not if we will attempt to forecast the the upcoming years to better see a possible trend (need team input). 

##Visualization:
```{r}
##df_ND[,266] is the last country (Zimbabwe). Because I set fin_ND[5:270], so we can skip the first 3 rows of zeros and country years
i = 1
while ( i < 267 ){
  sum_ND <- summary(as.double(df_ND[,i]))
  sum_API <- summary(as.double(df_API[,i]))
  sum_PG <- summary(as.double(df_PG[,i]))
  i = i + 1
  

}

#Used a while loop since it was better option.
#Next steps: Visualization: Provide preliminary visualization in the form of histograms, density plots, scatter plots, boxplots, and numerical summaries of the data, depending on the type of analysis. What do these visualizations suggest about the hypothesis, model or simulation you are aiming to perform?

```

#Preliminary visualization:

```{r}
#Histogram and plot are horrible visualization for the data for ND
# While for API, it has way to many zeros so each of plots for a scatter and histo will end up screwing the data
# For PG, it would be good for which ever the one. However, since its horrible for the 2 other data sets so it might be better to run a linear regression anaylsis. 

```

```{r}
library("ggplot2")
library("stargazer")
#If we want a linear regression to run, we must keep each df_ND$ as a double type since as a character an output occurs but it looks messy for summary()

A1 <- lm(as.double(df_API$Australia) ~ as.double(df_API$Austria), data = df_API)

B1 <- lm(as.double(df_API$`Viet Nam`) ~ as.double(df_API$Vanuatu), data = df_API)

C1 <- lm(as.double(df_ND$Australia) ~ as.double(df_ND$Austria), data = df_ND)

D1 <- lm(as.double(df_ND$`Viet Nam`) ~ as.double(df_ND$Vanuatu), data = df_ND)

E1 <- lm(as.double(df_ND$Spain) ~ as.double(df_ND$Estonia), data = df_ND)
```

```{r}
#four is the max amount of lm() we can have per stargazer(), because 5 gets crowded.I'm confuse on why its outputting Warning......
stargazer(A1,B1,C1,D1,
            header=FALSE,
            font.size = "tiny",
            type = "text",
            algin = TRUE,
            single = FALSE,
            column.sep.width = "1pt",
            digits =2)
stargazer(E1,
            header=FALSE,
            font.size = "tiny",
            type = "text",
            algin = TRUE,
            single = FALSE,
            column.sep.width = "1pt",
            digits =2)
```

